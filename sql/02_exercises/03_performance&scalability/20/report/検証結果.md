# SQLパフォーマンス検証レポート：第3章 パフォーマンスとスケーラビリティ（データ量がパフォーマンスに与える影響）
### 1. 検証の目的

複合インデックスにおいて、**「列の順番」** が実行計画とスケーラビリティ（データ増への耐性）にどのような影響を与えるかを、100万件のデータを用いて実証する。

---
### 2．検証環境
- **データ量:** 1,000,000件（`scale_data` テーブル）
- **検索条件:** `WHERE section = 'A' AND id2 = 999`
- **比較対象:**
  1. **悪い例:** `idx_slow (section, id1, id2)` ※id1が間に挟まっている
  2. **良い例:** `idx_fast (section, id2)` ※検索条件が先頭に並んでいる

---
### 3. 検証結果サマリー

| 比較パターン       | 書き方                | 実行計画          | 実行時間       | 判定                        |
|-------------------|----------------------|-------------------|---------------|----------------------------|
| ① 列順が不適切     | `(section, id1, id2)` | Parallel Seq Scan | **145.6 ms** | NG:インデックスが無視された  |
| ② 強制 Index Scan | `(section, id1, id2)` | Index Scan        | **314.4 ms** | 最悪：全件走査よりも遅い     |
| ③ 最適な列順       | `(section, id2)`      | Index Only Scan  | **1.0 ms**   | 爆速: アクセス述語が機能     |

---
### 4. 分析と考察
**① 「インデックス使用 = 速い」という誤解**

 検証②では、インデックスを使ってはいるものの、`section` しか絞り込みに使えず、残りの `id2` は読み取った後に捨てる（フィルタ）作業が発生した。
 
 この「広すぎるスキャン」は、ランダムアクセスの負荷によりフルスキャン（全件走査）よりも遅くなるという逆転現象を引き起こした。

**② 列順が生む「アクセス述語」の威力**

 検証③では、検索条件の `section` と `id2` がインデックスの先頭から順に並んでいるため、B-Treeを最下層まで一気に降りてピンポイントでデータを特定できた。

**Index Cond:** `(section = 'A' AND id2 = 999)` となり、無駄な読み取りがゼロになった。

**③ 現場で直面する「運用の罠」**

 正しいインデックスを貼っても、以下の要因で効果が出ないことを実機で確認した。

- **統計情報:** `ANALYZE` を実行しないと、DBはデータの少なさを誤認し、インデックスを避ける。

- **型の不一致:** `CHAR(1)` 列に `TEXT` で比較すると、インデックスが機能しない。
`::char(1)` と型を明示して初めてインデックスが目を覚ました。

---
### 5. 結論

**鉄則:「WHERE句の条件は、インデックスの先頭に隙間なく並べよ」**

**教訓:** 実行計画で見るべきは「Index Scan」という文字ではなく、`Index Cond`（アクセス述語） に全ての条件が入っているかどうかである。

**スケーラビリティ:** フィルタ述語（Filter）に頼る設計は、データ増大時に必ず破綻する。1msで終わる「壊れないSQL」こそが、真のパフォーマンスを生む。