# SQLパフォーマンス検証レポート：日付型と関数索引
### 1. 検証の目的
日付型検索における「関数適用の罠」を確認し、インデックスを最大限に活用するための「範囲検索」および「関数索引（Oracleエミュレーション）」の有効性を検証する。

---
### 2. 検証結果：ビフォー・アフター
| 検索手法                 | 実行計画          | 実行時間     | 評価     | 備考                                     |
|-------------------------|-------------------|-------------|---------|------------------------------------------|
| 列への関数適用 (to_char) | Parallel Seq Scan | 119.38 ms   | ×　遅い  | 全件走査 + 100万回の関数計算が発生          |
| 範囲指定検索 (>= AND <)  | Index Only Scan   | 5.36 ms     | ○　最速  | インデックスのみで完結。データ本体に触れない |


---
### 3. 分析と考察
**① 「関数適用の罪」の可視化**

検証により、列側に関数をかけるとDBは「インデックスという地図」を捨て、全データを力ずくで読み込むことが証明された。
- **Parallel Seq Scan:** CPUリソースを大量に消費し、スケールを阻害する。
- **Filter:** 読み込んだ後に「捨てる」作業が発生し、無駄が極めて大きい。

**② PostgreSQLとOracleの「NULL」哲学**

今回の関数索引エミュレーションで最も興味深かったのは、インデックスサイズの結果。
- **Oracle:** NULL を「無」とみなし、インデックスから物理的に除外してサイズを極小化する。
- **PostgreSQL:** NULL も「状態の一つ」としてインデックス内に保持し続ける。

**教訓:**

 PostgreSQLでサイズ節約（部分インデックス）を狙うなら、関数索引ではなく WHERE 句付きの Partial Index を使うのが正解。

**③ 範囲検索が「唯一の正解」である理由**

`sale_date >= '2023-01-01' AND sale_date < '2023-01-02'` という書き方は、以下の3点を同時に満たす最強の書き方。

1. **SARGable:** インデックスが100%効く。

2. **正確性:** 時間成分（23:59:59.999...）の取りこぼしがない。

3. **互換性:** Oracle, MySQL, PostgreSQL すべてで高速に動く。


### 4. 結論
日付検索において **「列側に関数をかける」ことは、パフォーマンスに対する自傷行為** である。
 常に **「検索値（右側）を計算し、列（左側）は生のまま範囲で攻める」** ことが、プロフェッショナルなSQLの鉄則である。