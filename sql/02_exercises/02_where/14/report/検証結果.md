# SQLパフォーマンス検証レポート：第2章 WHERE句（NOT NULL制約）
### 1. 検証の目的
Oracle等のDBにおいて、`IS NULL` 検索でインデックスが使われるための絶対条件である「インデックスに全行が含まれていること（NOT NULL制約の存在）」が、PostgreSQLにおいてどのような影響を与えるかを確認する。
また、ユーザー定義関数（UDF）が制約を「隠してしまう」挙動とその対策を検証する。

---
### 2. 検証環境
- DB: PostgreSQL 16.x (Docker container)

- データ量: 1,000,000件

- テーブル構成:
```sql
CREATE TABLE employees_notnull (
    employee_id INT PRIMARY KEY, -- 強力な NOT NULL 制約
    date_of_birth DATE,          -- NULL許可
    name TEXT
);
```

---
### 3. 検証結果：インデックスサイズ
| インデックス名              | 構成                          | サイズ  | 分析  |
|----------------------------|------------------------------|---------|------|
| idx_notnull_combo          | (dob, emp_id)                | 22 MB   | 生のカラム（NOT NULL列）を組み合わせた構成。 |
| idx_udf_combo              | (dob, my_blackbox(emp_id))   | 22 MB   | 関数結果を格納。計算結果を保存するためサイズは同等。 |

　
---
### 4. 実行計画の比較
**パターン①：ユーザー定義関数（UDF）を含む索引での IS NULL 検索 クエリ:** `WHERE date_of_birth IS NULL`
```text
Bitmap Index Scan on idx_dob_with_constant (actual time=4.509..4.510 rows=10000)
  Index Cond: (date_of_birth IS NULL)
Execution Time: 15.144 ms
```
**分析:**

PostgreSQLは、関数を含んでいても「この索引は利用可能」と判断。

Oracleのように「UDFが含まれると全行あるか不明なのでIS NULL検索には使わない」という極端な制限は受けなかった。

---
**パターン②：Oracle流の対策（IS NOT NULLを明示）を適用 クエリ:** `WHERE date_of_birth IS NULL AND my_blackbox(employee_id) IS NOT NULL`

```text
Bitmap Index Scan on idx_notnull_combo (actual time=16.421..16.429 rows=10000)
  Index Cond: (date_of_birth IS NULL)
  Filter: (my_blackbox(employee_id) IS NOT NULL)
Execution Time: 54.453 ms
```
**分析:**

条件を増やしたことでオプティマイザが再計算。
関数評価を後に回す（Filter）方が確実と判断し、使用される索引が切り替わった。
実行時間は伸びたが、「どの索引が最も安全か」をDBが論理的に判断していることが確認できた。

 ---
 ### 5. 考察・結論
**1. NOT NULL制約の「情報の価値」:** Oracleでは `NOT NULL` 制約が「インデックスを使って良いか」のスイッチになるが、PostgreSQLでは「どのインデックスが低コストか」を判断する材料になる。いずれにせよ、制約はオプティマイザに**数学的な確証**を与える重要な情報である。

**2. UDF（ユーザー関数）の取り扱い:** 関数はDBにとって「中身が不明な箱」である。関数をインデックスに含める場合は、今回のように `IMMUTABLE` 等の属性を正しく付与し、DBがその挙動を予測できるように設計することがパフォーマンス維持の鍵となる。
