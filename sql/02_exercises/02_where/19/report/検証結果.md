# SQLパフォーマンス検証レポート：第2章 WHERE句（スマートなロジック）
### 1. 検証の目的

「全ての検索パターンを1本のSQLでこなす（万能SQL）」と「必要な条件だけをその都度組み立てる（動的SQL）」を比較し、実行計画の精度とリソース消費量への影響を検証する。

---
### 2．検証環境

- **データ量:** 1,000,000件（過去3年分のログデータ）
- **対象テーブル:** `inventory`(在庫テーブル)
- **インデックス:** `idx_inv_warehouse` (warehouse_id)

---
### 3. 検証結果サマリー

| 比較パターン      | 書き方                          | 実行計画          | 実行時間     | 結果                     |
|------------------|--------------------------------|-------------------|-------------|--------------------------|
| ① 万能SQL (NG例)　| `(col = :val OR :val IS NULL)` | Parallel Seq Scan | **64.5 ms** | インデックス破棄・全件走査 |
| ② 動的SQL (正解)  | `col = :val`                   | Bitmap Index Scan | **21.5 ms** | 約3倍の高速化             |

---
### 4. 分析と考察
**① オプティマイザの「迷い」と「安全策」**

万能SQL（パターン①）では、`OR` や `IS NULL` といった抽象的な条件が含まれるため、DBは「どのインデックスを使うのが正解か」を判断できない。

その結果、**「何が来ても間違いがない、最も安全で最も遅い手段（全件走査）」** を選択するようになる。

**② 計算リソースの浪費**

`Parallel Seq Scan` が選ばれたことで、DBは3つのCPUスレッドをフル稼働させ、100万行すべてに対して「パラメータがNULLかどうか」の判定を繰り返した。

一方で動的SQL（パターン②）は、迷わずインデックスを選択し、スレッド1つで効率的にデータを抽出できている。

**③「直書き」の罠**

検証中、SQLに直接数値を書くとインデックスが使われることがあったが、これはDBが「ズル（定数畳み込み）」をしたため。

プログラムからバインド変数で渡す実際の運用では、DBは値を予測できないため、今回再現したような　**「最悪の計画」に固定されるリスク**　が極めて高いと言える。

---
### 5. 結論:

- **原則:** SQLは「多機能」にせず、**「単機能」**に保つ。

- **実装の鉄則:** プログラム側（MyBatisやJPA、自作ラッパーなど）でIF文を使い、**必要なWHERE句のパーツだけを結合する「動的SQL」**を採用する。

- **運用上のメリット:** 不要な `OR` や `NULL` 判定を削ぎ落とすことで、Planning Time（解析時間）も短縮され、サーバー全体の負荷を劇的に下げることができる。