# SQLパフォーマンス検証レポート：第2章 WHERE句（部分インデックスのエミュレート）
### 1. 検証の目的
Oracleの「すべてのインデックス列がNULLの行はインデックスに格納されない」という特性を利用し、
関数索引を用いて**特定条件の行だけを抽出する部分インデックス**を擬似的に実装し、その有効性を検証する。

---
### 2. 検証の仕組み
- **フィルタリング関数:** `processed = 'N'`（未処理）の時だけ値を返し、それ以外は `NULL` を返す `IMMUTABLE` 関数を作成。

- **インデックス:** その関数結果をキーとした関数索引（`idx_oracle_emulation`）を作成。

- **検索:** クエリの `WHERE` 句に関数式を直接記述して検索。

---
### 3. 検証結果と分析
| 項目              | 結果       | 分析                                                   |
|------------------|------------|--------------------------------------------------------|
| 実行時間          | 0.182 ms   | 100万件の中から瞬時に特定。全件走査を完全に回避。          |
| 実行計画          | Index Scan | インデックス定義の関数式とクエリの記述が一致し、正常に機能。|
| インデックスサイズ | 6,920 kB   | 全件インデックス（6,944 kB）とほぼ変わらず。              |

**PostgreSQL特有の挙動**

Oracleでは NULL を返した行はインデックスから消えるため、サイズが激減します。
しかし、今回の検証により、**PostgreSQLはNULLであってもインデックスに含め続ける**ため、サイズ節約の効果は得られないことが判明しました。　

---
### 4. 考察・結論
**1. 検索効率の極大化:** 
「関数を通した検索」であっても、インデックスの定義と一致していれば爆速で動作する。
Oracleのようなネイティブな部分インデックスがない環境では、極めて有効な高速化手法となる。

**2. 設計上のトレードオフ:** この手法は「クエリの書き方をインデックスに合わせる」必要があるため、SQLの可読性が下がる。
PostgreSQL  のようなネイティブな部分インデックス（`WHERE` 付き索引）が使える環境では、そちらを優先すべきである。

**3. 製品ごとの「NULL」の哲学:** 
本検証を通じ、PostgreSQLは「NULLもデータとして一貫して管理する」のに対し、
Oracleは「NULLは無（存在しないもの）として扱うことで効率化を図る」という、両DBの設計思想の違いが浮き彫りになった。