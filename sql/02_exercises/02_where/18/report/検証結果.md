# SQLパフォーマンス検証レポート：第2章 WHERE句（列の連結）
### 1. 検証の目的

「日付」と「時刻」が別々の列に分かれているテーブルに対し、それらを連結・加工して検索した際のパフォーマンスへの影響と、インデックスを再活性化させる救済策を検証する。

---
### 2．検証環境

- **データ量:** 1,000,000件（過去3年分のログデータ）
- **対象列:** `date_part` (DATE), `time_part` (TIME)
- **インデックス:** `idx_date_time` (date_part, time_part) の複合インデックス

---
### 3. 検証結果サマリー

| 比較パターン      | 書き方                             | 実行計画          | 実行時間     | 結果                 |
|------------------|-----------------------------------|-------------------|-------------|----------------------|
| ① 連結（NG例）　  | `(date + time) > ?`               | Parallel Seq Scan | **99.4 ms** | インデックスを完全無視 |
| ② 救済（次善策）  | `(date + time) > ? AND date >= ?` | Index Only Scan   | **2.3 ms**  | 約40倍の高速化        |

---
### 4. 分析と考察
**① なぜ連結すると遅いのか（パターン①）**

DBはインデックス（地図）を持っていても、`date_part + time_part` という「加工後の値」がどこにあるかは知らない。

そのため、**100万行すべてに対して連結計算を行い、その結果を一つずつチェックする**という「力技（全件走査）」が発生した。

**② 「魔法の1行」による劇的改善（パターン②）**

検索条件に、複合インデックスの先頭列である date_part >= ... を追加したことで、DBの挙動が劇的に変わった。

1. **Index Cond（絞り込み）:** 
先頭列の条件を使い、インデックス内で「昨日の0時以降」の場所へワープ。対象を約0.2%（2,000行弱）まで絞り込む。

2. **Filter（精密検査）:** 
絞り込まれた2,000行に対してのみ、連結計算を実行して正確な結果を出す。

**結論:**

 100万回の計算を2,000回に減らしたことが、40倍の高速化の正体。


**結論:**

 型を合わせることは、単なる高速化ではなく、システムの **堅牢性（エラーの起きにくさ）** に直結する。

---
### 5. 結論:

- **原則:** WHERE句で列を演算・連結させてはいけない。

- **設計時の鉄則:** 検索対象となるデータ（日付と時刻など）は、最初から**一つの列（TIMESTAMP型など）にまとめて保存する**のがベスト。

- **運用時の知恵:** 設計変更ができない場合でも、**「インデックスの先頭列だけでも絞り込める条件」を添える**ことで、全件走査という最悪の事態を回避できる。