# SQLパフォーマンス検証レポート：第2章 WHERE句（数値文字列と型変換）
### 1. 検証の目的
数値が文字列型（VARCHAR）で保存されている列に対し、数値として検索を行った際の**「暗黙の型変換」による影響（パフォーマンス低下および実行時エラーのリスク）**を検証する。
---
### 2．検証環境
- **データ量:** 1,000,000件（連番）+ 1件（不純物 'ABC'）
- **対象列:** `product_code` (VARCHAR) ※インデックスあり（21 MB）

---
### 3. 検証結果サマリー
| 比較パターン          | 書き方           | 実行計画            | 実行時間 | 結果・リスク                  |
|----------------------|-----------------|---------------------|---------|------------------------------|
| ① 正常（型一致）　     | `='500000'`       | Index Scan         |  **1.2 ms** | 最速。不純物があっても安全。    |
| ② 暗黙（PostgreSQL）  | `= 500000`        | (Error)            |    -    | 実行不可（型安全による保護）。  |
| ③ 強制変換（列側）     | `::int = 500000`  | Parallel Seq Scan  | **55.2 ms** | 45倍以上遅い。 リソースを浪費。 |
| ④ 不純物混入時         | `::int = 500000` | (Error)             |   -    | 'ABC' 読み込み時にクラッシュ。  |

---
### 4. 分析と考察
**① 「21MBの武器」の放棄**

正常パターンではインデックス（21MB）を使い、100万件から1件をピンポイントで特定しました。

一方、列側をキャストしたパターンでは、DBはインデックスを完全に無視し、全データをメモリに読み込む `Seq Scan` を選択しました。

**② 計算コストと並列処理の代償**

`Parallel Seq Scan` では、**100万行に対して「文字列→数値」の変換計算が100万回発生しました。**

この重い処理をこなすため、DBは**3つのプロセス（スレッド）**を動員しており、`1.2ms`で終わる処理に`55ms`（CPU時間としてはその3倍）を費やすという、極めて非効率な結果となりました。

**③ 運用上の最大リスク：時限爆弾**

不純物（'ABC'）が混じった際のエラーは、本番環境における「時限爆弾」です。

- **インデックスが効く場合:** 'ABC' の行を読み飛ばすため、エラーは起きない。

- **型変換が起きる場合:** 全行を変換しようとして 'ABC' に触れた瞬間にクエリが停止する。


**結論:**

 型を合わせることは、単なる高速化ではなく、システムの **堅牢性（エラーの起きにくさ）** に直結する。

---
### 5. 結論:

1. **左側（列）を加工せず、右側（検索語）を列の型に合わせる。**
   - × `WHERE product_code::int = 500000`

   - ○ `WHERE product_code = '500000'`

2. PostgreSQLがエラーを出すのは、この「時限爆弾」からシステムを守るための優秀な防御機能である。

3. 数値として扱うべきデータは、本来 **数値型（INTEGER等）** で設計すべきである。