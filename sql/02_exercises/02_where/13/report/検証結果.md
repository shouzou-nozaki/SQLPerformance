# SQLパフォーマンス検証レポート：第2章 WHERE句（NULLによるインデックス）
### 1. 検証の目的
Oracleにおける「すべてNULLの行はインデックスに含まれない」という制約と、それを解決する手法(複合インデックスや定数列)の有効性をPostgreSQLで検証する。

---
### 2. 検証環境
- DB: PostgreSQL 16.x (Docker container)

- データ量: 1,000,000件

- テーブル構成:
```sql
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    subsidiary_id INT NOT NULL,
    date_of_birth DATE,
    name TEXT
);
```
---
### 3. 検証結果：
インデックスサイズ各手法で作成したインデックスの物理サイズを比較した。
| インデックス名              | 構成                         | サイズ     | 分析 |
|----------------------------|------------------------------|------------|------|
| idx_dob_single             | (date_of_birth)              | 6,944 kB   | PostgreSQLは単一列でもNULLを格納するため、これが基準サイズとなる。 |
| idx_dob_with_constant      | (date_of_birth, 1)           | 6,944 kB   | 定数を追加してもサイズ増なし。Oracleで「全行をインデックスに含める」ためのテクニック。 |
| idx_subsidiary_dob         | (subsidiary_id, date_of_birth) | 9,344 kB | 列が増えた分、サイズは約1.3倍に増加。その分、検索効率は大幅に向上した。 |


---
### 4. 実行計画の比較
**パターン①：単一列（定数付与）でのIS NULL検索 クエリ:** `WHERE date_of_birth IS NULL`
```text
Bitmap Index Scan on idx_dob_with_constant (actual time=4.509..4.510 rows=10000)
  Index Cond: (date_of_birth IS NULL)
Execution Time: 15.144 ms
```
**分析:**

 PostgreSQLでは単一列インデックスにNULLが格納されているため、Oracleのような工夫なしでもインデックス検索が可能。
 
 ただし、100万件からの抽出には約15msを要した。


---
**パターン②：複合インデックスによる絞り込み クエリ:** `WHERE subsidiary_id = 5 AND date_of_birth IS NULL`

```text
Bitmap Index Scan on idx_subsidiary_dob (actual time=2.375..2.376 rows=1029)
  Index Cond: ((subsidiary_id = 5) AND (date_of_birth IS NULL))
Execution Time: 4.379 ms
```
**分析:**

 実行時間が約3.5倍高速化された。 
 
 先頭の subsidiary_id で範囲を劇的に絞り込んだ直後に IS NULL を判定できるため、B-treeの走査効率が極めて高い。

 ---
 ### 5. 考察・結論
1. **PostgreSQLにおけるNULLの扱い:** PostgreSQLは単一列インデックスでもNULLを保持するため、Oracleのような「NULLをインデックスに入れるためのトリッキーな工夫（定数の追加など）」は検索可否の面では不要である。

2. **複合インデックスの優位性:** 「NULLであること」を条件にする検索は、単体ではカーディナリティ（識別性）が低くなりがちだが、他の `NOT NULL` 列と組み合わせることで、Oracleの制約を回避しつつ、検索を劇的に高速化できる。

3. **設計上の注意:** 「すべての列がNULLの行はインデックスに含まれない」というOracleの特性を理解しておくことは、製品移行やマルチプラットフォーム対応の設計において非常に重要。PostgreSQLでは「NULL検索も普通の検索と同じ」と考えて良いが、パフォーマンスのために複合インデックスを活用する原則は変わらない。