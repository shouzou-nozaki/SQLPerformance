# SQLパフォーマンス検証レポート：第2章 WHERE句（数式）
### 1. 検証の目的

WHERE句において、列に対して算術演算（数式）を行った場合のパフォーマンスへの影響と、「関数インデックス」による救済、および「定数側への計算の集約」の効果を比較検証する。

---
### 2．検証環境

- **データ量:** 1,000,000件（`sensor_data`テーブル）
- **対象列:** `value_a`(INT)
- **インデックス:** 
  1. `idx_value_a` (通常のB-tree)、
  2. `idx_math_expression`(式 `value_a - 1000` に対する関数インデックス)

---
### 3. 検証結果サマリー

| 比較パターン         | 書き方                | 実行計画          | 実行時間     | 結果            |
|---------------------|----------------------|-------------------|-------------|-----------------|
| ① 列を加工 (通常IDX) | `value_a - 1000 > ?` | Seq Scan          | **17.8 ms** | インデックス不可  |
| ② 定数側で計算       | `value_a > ? + 1000` | Bitmap Index Scan | **2.4 ms**  | 爆速（原則）      |
| ③ 関数インデックス   | `value_a - 1000 > ?` | Bitmap Index Scan | **2.3 ms**  | 特定の式にのみ有効 |

---
### 4. 分析と考察
**① DBは「逆算」をしてくれない**

DBのオプティマイザは、`value_a - 1000 > 50000` という式を見ても、それを `value_a > 51000` と解釈して通常のインデックスを使うような「方程式の変形」は行わない。

列に手が加わった瞬間に、通常のインデックスはただの「数値のリスト」に成り下がり、検索には使えなくなる。

**② 定数畳み込みの恩恵**

`value_a > 50000 + 1000` と書いた場合、DBは実行前に `51000` という定数に計算を済ませてくれる。

これにより、列側が「裸」の状態に保たれ、標準的なインデックスがフル活用される。

**③ 関数インデックスの威力と制約**

`CREATE INDEX ... ON ((value_a - 1000))` と定義することで、式の結果をあらかじめ計算してインデックス化できる。

- **メリット:** SQLの書き方を変えられないレガシーな環境で劇的な効果を発揮する。

- **デメリット:** インデックス作成時と**一字一句同じ式**をWHERE句に書かないと適用されない。汎用性が極めて低い。

---
### 5. 結論:

- **鉄則:「列は裸にして比較せよ」**

- **実践:** 計算が必要な場合は、必ず不等号の右側（検索値側）で計算を行うようにSQLを記述する。

- **関数インデックスの使い所:** 設計変更が許されない場合の「最終兵器」としてのみ検討する。