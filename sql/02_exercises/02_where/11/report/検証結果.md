# SQLパフォーマンス検証レポート：第2章 WHERE句（部分インデックス）
### 1. 検証の目的
データの分布に大きな偏りがある場合（例：99%が処理済み、1%が未処理）、テーブル全体ではなく特定の条件を満たす行だけに作成する「部分インデックス」が、サイズとパフォーマンスにどのような影響を与えるかを実証する。

### 2. 検証環境
- DB: PostgreSQL 16.x (Docker container)

- データ量: 1,000,000件

- テーブル構成:
```sql
-- 実験用テーブル作成
CREATE TABLE messages (
    message_id SERIAL PRIMARY KEY,
    receiver_id INT NOT NULL,
    processed CHAR(1) NOT NULL CHECK (processed IN ('Y', 'N')),
    content TEXT
);
```

- データ分布:
  - `processed = 'Y'` (処理済み): 990,000件 (99%)

  - `processed = 'N'` (未処理): 10,000件 (1%)

### 3. 検証結果と実行計画
**パターン①：インデックスサイズの比較**

**状態:** 通常のマルチカラムインデックスと部分インデックスを作成
```sql
-- フルインデックス
CREATE INDEX idx_messages_full ON messages (receiver_id, processed);
-- 部分インデックス
CREATE INDEX idx_messages_partial ON messages (receiver_id) WHERE processed = 'N';
```
**結果:**
```text
| index_name | index_size | 
| :--- | :--- |
| idx_messages_full | 6864 kB | 
| idx_messages_partial | 208 kB |
```

**分析:**

部分インデックスは、不要なデータ（'Y'）をインデックスから除外することで、通常のインデックスと比較して**約97%のサイズ削減**に成功している。

ディスク容量だけでなく、メモリ（バッファキャッシュ）の節約にも極めて有効。

---
**パターン②：未処理データの検索（部分インデックスの適用）**

**状態:** 両方のインデックスが存在する状態で検索 

**クエリ:** `WHERE processed = 'N' AND receiver_id = 500`

```text 
Index Scan using idx_messages_partial on messages  (cost=0.29..8.30 rows=1 width=43) (actual time=0.678..0.694 rows=1 loops=1)
   Index Cond: (receiver_id = 500)
Planning Time: 7.689 ms
Execution Time: 0.775 ms
```
**分析:**

**1. 最適解の選択:**

 DBは、巨大なフルインデックスよりも、軽量な `idx_messages_partial` を優先して使用した。

**2. 検索キーの効率化:**

 インデックス自体が `processed = 'N'` であることが保証されているため、インデックス内の検索条件（Index Cond）から `processed` 列が省略されており、検索効率が最大化されている。


 ### 4. 考察・結論
**1. 「小ささは正義」の実証:**

部分インデックスは、特定のステータス（未処理、有効、エラーなど）に偏った検索において、劇的なリソース節約と高速化を両立できる。

1ミリ秒を切るレスポンスタイムがその性能を証明している。

**2. 横方向と縦方向の削減:**

対象行数を絞る（縦方向）だけでなく、検索条件として確定している列をインデックスから除外する（横方向）ことで、インデックスを極限まで軽量化できることが確認できた。

**3. OLTP環境での有用性:**

全件を検索対象にせず、頻繁にアクセスされる「アクティブなデータ」のみを対象にすることで、巨大なテーブルでもインデックスをメモリに載りやすく保つことができ、高負荷な環境に非常に適している。