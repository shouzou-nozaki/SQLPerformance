# SQLパフォーマンス検証レポート：第2章 WHERE句（インデックスの結合）

### 1. 検証の目的
単一カラムインデックスの組み合わせ(インデックス結合)　と　マルチカラムインデックス(複合インデックス)　の挙動を比較し、クエリ条件(等価・範囲)が実行計画に与える影響を確認する。

### 2. 検証環境
- DB: PostgreSQL 16.x (Docker container)
- データ量: 1,000,000件
- テーブル構成:
```sql
-- 実験用テーブル作成
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT,
    email TEXT,
    created_at TIMESTAMP
);
```

### 3. 検証結果と実行計画
**パターン①：インデックスなし(フルスキャン)**

**状態:** 初期状態  
**クエリ:** `WHERE customer_id = 5000 AND order_date > '2025-01-01'`
```text
Gather (actual time=3.636..85.535 rows=45)
  -> Parallel Seq Scan on orders
       Filter: ((order_date > '2025-01-01') AND (customer_id = 5000))
       Rows Removed by Filter: 333318
Execution Time: 85.771 ms
```
**分析:**

100万件を力押しで読み取っている。並列処理（Parallel）が動いているが、件数が増えると致命的に遅くなる。

**パターン②：個別のインデックスを作成（インデックス結合の不発）**

**状態:** `idx_customer` と `idx_date` を個別に作成 
**クエリ:** 同上

```text
Bitmap Heap Scan on orders (actual time=0.583..0.702 rows=45)
  -> Bitmap Index Scan on idx_customer (actual time=0.559..0.559 rows=88)
       Index Cond: (customer_id = 5000)
  Filter: (order_date > '2025-01-01')
Execution Time: 0.813 ms
```
**分析:**

書籍で紹介される「BitmapAnd」による結合は起きなかった。
理由は、customer_id だけで十分に絞り込める（88件）ため、もう一方の索引を引くコストをオプティマイザが回避したため。

### パターン③：マルチカラムインデックス（等価条件）
**状態:** `idx_cust_date(customer_id, order_date)` を作成 
**クエリ:** 同上（`customer_id = 5000`）

```text
Bitmap Heap Scan on orders (actual time=2.273..2.298 rows=6)
  -> Bitmap Index Scan on idx_cust_date (actual time=2.257..2.258 rows=6)
       Index Cond: ((customer_id = 5000) AND (order_date > '2025-12-01'))
Execution Time: 2.326 ms
```
**分析:**

索引の先頭カラムが等価条件（`=`）のため、2番目の日付条件も索引内で効率的に絞り込まれている。
非常に高速。

**パターン④：マルチカラムインデックス（範囲条件の罠）**
**状態:** `idx_cust_date` を維持 
**クエリ:** `WHERE customer_id BETWEEN 1000 AND 5000 AND order_date > '2025-12-01'`

```text
Parallel Seq Scan on orders (actual time=0.009..25.527 rows=8692)
  Filter: (customer_id >= 1000 AND customer_id <= 5000 AND order_date > '2025-12-01')
Execution Time: 59.914 ms
```

**分析:**

第一引数が範囲条件（`BETWEEN`）になったことで、2番目のカラムでの絞り込み効率が低下。
結果として「全件走査の方が早い」と判断され、インデックスが無視された。

### 4. 考察・結論
**1. マルチカラム索引の優先順位:**

クエリが固定されているなら、マルチカラム索引が最強である。
ただし、**「等価条件のカラムを索引の先頭にする」** という設計が極めて重要。

**2. インデックス結合の現実:**

DBはインデックス結合（BitmapAnd）を「コストが高い」と見なす。

よって、アドホックな検索（多次元の絞り込み）が多いDWHのような環境でない限り、複合索引を適切に設計する方がOLTP環境では有利。

**3.実行計画の変動:**

データ量や分布（カーディナリティ）によって、同じクエリでも `Index Scan` が選ばれたり `Seq Scan` が選ばれたりする。 

インデックスを貼るだけでなく、常に実測（EXPLAIN ANALYZE）することが不可欠。