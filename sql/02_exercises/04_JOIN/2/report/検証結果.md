# SQLパフォーマンス検証レポート：第4章 結合処理（ハッシュ結合）
### 1. 検証の目的

ハッシュ結合において、**「結合列のインデックスの有無」および「SELECT句の列選択（メモリ消費）」**　が、実行計画とパフォーマンスにどのような影響を与えるかを実証する。

---
### 2．検証環境
- **データ量:**
  - `sales` (1,000,000件/巨大な履歴テーブル)
  - `employees` (10,000件/マスタテーブル)
- **条件** `sales` と `employees` を `employee_id` で等価結合

---
### 3. 検証結果サマリー

| 比較パターン        | 書き方          | 実行計画             | Memory Usage | 実行時間  |
|--------------------|----------------|----------------------|--------------|----------|
| ① インデックスの確認 | `SELECT *`     | Hash Join (Seq Scan) | **1075 kB**  | 1999 ms  |
| ② メモリ最適化      | `SELECT 指定列` | Hash Join (Seq Scan) | **636 kB**   | 742 ms   |

---
### 4. 分析と考察
**① ハッシュ結合におけるインデックスの「無力さ」**

検証①では、結合キー（`id`）にインデックスが存在していても、DBはそれを一切使わず `Seq Scan`（**全件走査**） を選択した。

- **理由:** 
ハッシュ結合は「一度に全データを読み込んでハッシュテーブルを作る」戦略であるため、B-treeを1行ずつ辿るインデックス走査よりも、一気にメモリへロードするフルスキャンのほうが効率的だから。

- **教訓:** 
結合条件（ON句）にインデックスを貼るだけでは、ハッシュ結合の高速化には繋がらない。


**② `SELECT *` が引き起こす「ハッシュ肥大化」**

検証②において、取得する列を絞っただけで**メモリ使用量が約40%削減、速度が約2.7倍向上した。**

- **理由:**
 ハッシュテーブルは「行数」だけでなく「行の幅（width）」によってサイズが決まる。
 不要な列（`note`等）を含めるとハッシュテーブルが肥大化し、CPUキャッシュの効率が落ち、最悪の場合はディスク溢れ（Disk Spill）を引き起こす。

**教訓:**
 ORMによる「全件取得」はハッシュ結合の最大の敵である。

**③ スケーラビリティの分岐点**

今回の 10,000件程度では `Batches: 1`（メモリ完結）で済んだが、データ増大時に `Memory Usage` が `work_mem` を超えた瞬間、ハッシュ結合はディスクI/Oを発生させ、パフォーマンスは垂直落下する。

---
### 5. 結論
**1. ハッシュ結合の最適化は「WHERE句」から:**

結合列のインデックスではなく、ハッシュテーブルを作る前にデータを絞り込むための「独立したWHERE条件」にこそインデックスが必要である。

**2. 「列のダイエット」は必須:**

 必要な列だけを選択することは、単なる帯域の節約ではなく、**DB内部のメモリ設計を最適化する高度なチューニングである。**

**3. 「軽い負荷」での成功を疑う:**

 開発環境の一人アクセスで速くても、メモリを大量消費する `SELECT *` のクエリは、本番環境の同時アクセス（メモリの奪い合い）が発生した瞬間に破綻する。