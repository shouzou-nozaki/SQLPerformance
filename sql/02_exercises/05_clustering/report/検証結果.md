# SQLパフォーマンス検証レポート：第5章 データのクラスタリング（フィルタ述語）
### 1. 検証の目的

インデックスの役割を「検索範囲の特定」だけでなく、**「テーブルアクセスの抑制（クラスタリングの改善）」**として捉え直し、複合インデックスによるフィルタリングがI/Oコストに与える影響を実証する。

---
### 2．検証環境
- **データ量:** `employees` (100,000件)
- **クエリ:** `WHERE subsidiary_id = 5 AND UPPER(last_name) LIKE '%A%'`
- **インデックス構成:** `(subsidiary_id)`単一列、`(subsidiary_id, UPPER(last_name))`複合列

---
### 3. 検証結果サマリー

| 比較パターン  | インデックスの役割     | 実行計画          | フィルタの位置       | 備考                       |
|--------------|----------------------|-------------------|--------------------|----------------------------|
| ① 単一列      | `SELECT *`          | Bitmap Index Scan | **テーブル(heap)**  | 1.1万行すべてをテーブル確認  |
| ② 複合列      | `SELECT 指定列`      | Bitmap Index Scan | **インデックス内**  | 1375行をテーブル確認前に除去 |

---
### 4. 分析と考察
**① フィルタ述語による「出張キャンセル」**

検証②では、インデックス内に `UPPER(last_name)` を含めることで、**「Rows Removed by Filter: 1375」** がインデックス走査の段階で発生した。

- **効果:** 
本来ならテーブル（Heap）まで読みに行かないと分からなかった「不要な行」を、インデックスの段階で切り捨てた。

- **本質:** これは、物理的なデータの並び（クラスタリング）が悪くても、**インデックスを「高機能な防波堤」にすることで、高コストなテーブルアクセスを減らせる**ことを意味する。

**② オプティマイザの「賢さ」という壁**

検証中、`Bitmap Scan` や `Seq Scan` が選ばれ、期待した `Index Scan` がなかなか出ない場面があった。

- **理由:** PostgreSQLは、アクセス対象が全データの10%（1万行）を超えると、「バラバラに1万回アクセスするより、全部一気に読んだ方が（HDD/SSDの特性上）速い」と判断するため。

- **教訓:** インデックスの効果は、単一のクエリ速度だけでなく、**「どれだけ無駄なブロック読み込み（Buffers）を減らしたか」** という負荷の観点で見る必要がある。


**③ 「インデックスを太らせる」ことの正当化**

通常、インデックスの列数を増やすのは書き込み負荷を上げるため嫌われるが、今回のような **「テーブルアクセスのコストが支配的なクエリ」** においては、フィルタ列の追加は非常に有効な戦略となる。

---
### 5. 結論
**1. インデックスは「盾」である:**

インデックスはスキャン範囲を狭める（アクセス述語）だけでなく、テーブルへのアクセス回数を防ぐ（フィルタ述語）ための盾として設計すべきである。

**2. クラスタリングは論理的に改善できる:**

テーブルの行を物理的に並べ替えるのは困難だが、インデックスにフィルタ列を追加することで、「必要なデータだけを固めて取り出す」のと同等の効果を擬似的に得られる。

**3. データ量とメモリの罠:**

今回の検証では実行時間に劇的な差が出なかったが、これはデータがキャッシュ（メモリ）に載っていたため。**データ量がメモリを超え、物理I/O（ディスク読み込み）が発生する環境において、この「出張キャンセル」の差がシステムの命運を分ける。**