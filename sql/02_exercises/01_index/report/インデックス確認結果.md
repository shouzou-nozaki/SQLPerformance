## SQLパフォーマンス検証レポート：B-treeインデックスの効果
### 1. 検証の目的
『SQLパフォーマンス詳解』の学習に基づき、大量データ（100万件）に対してインデックスが検索速度にどのような影響を与えるかを、実行計画（EXPLAIN）を用いて定量的に検証する。

### 2. 検証環境
- DB: PostgreSQL 16.x (Docker container)
- データ量: 1,000,000件
- テーブル構成:
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT,
    email TEXT,
    created_at TIMESTAMP
);
```

### 3. 検証手順
1. `generate_series` を用いて100万件のダミーデータを投入。
2. インデックスがない状態で `name` カラムによる検索を実行し、実行計画を取得。
3. `name` カラムに B-tree インデックスを作成。
4. インデックスがある状態で同様の検索を実行し、実行計画を取得。

### 4. 検証結果
**4.1. インデックス未作成時 (Full Table Scan)**
- 実行クエリ: `EXPLAIN ANALYZE SELECT * FROM users WHERE name = 'User_999999';`
- **実行計画ログ:**
```text
Gather (actual time=52.372..55.169 rows=1 loops=1)
  Workers Planned: 2
  -> Parallel Seq Scan on users (actual time=29.465..29.466 rows=0 loops=3)
      Filter: (name = 'User_999999'::text)
Execution Time: 55.195 ms
```

**4.2. インデックス作成後 (Index Scan)**
- **作成コマンド:**
```sql 
CREATE INDEX idx_users_name ON users(name);
```

- **実行計画ログ:**
```text
Index Scan using idx_users_name on users (actual time=0.902..0.904 rows=1)
  Index Cond: (name = 'User_999999'::text)
Execution Time: 0.932 ms
```

### 5. 考察
**1. アルゴリズムの変化**
- 未作成時は Parallel Seq Scan（全件走査）が行われ、計算量は $O(n)$ となっていた。
- 作成後は Index Scan（B-tree探索）に切り替わり、計算量が $O(\log n)$ に削減された。
**2. パフォーマンス向上率**
- 実行時間は 55.195 ms → 0.932 ms となり、約 59倍 の高速化を達成した。
**3. Planning Time の割合**
- インデックス作成後は、検索そのもの（Execution）よりも、最適な経路を探す時間（Planning）の比重が相対的に高くなることを確認した。